:toc: macro
toc::[]

= How to create a devon4quarkus application

This guide should work as an introduction to the functionality given by https://quarkus.io/[Quarkus] and used in devon4quarkus and show to to build a first application.
The guide will cover:

* How to build a simple "Hello World" Quarkus app serving a hello endpoint.
* A short introduction to testing and the development mode in a quarkus app.
* Packaging the project and running as a self-contained jar file and producing a native executable. 

=== Prerequisites
To follow the guide and complete it, you need:

* an IDE or an editor to edit files
* JDK 11+ installed with JAVA_HOME configured appropriatly
* Apache Maven 3.8.1+


This guide is heavily inspired by https://quarkus.io/guides/[Quarkus Guides] and the katacoda tutorials by https://www.katacoda.com/openshift/courses/developing-with-quarkus[OpenShift for Quarkus Developement]. I would recommend also using the Katacoda tutorials to learn about quarkus.


https://quarkus.io/guides/getting-started
https://www.katacoda.com/openshift/courses/developing-with-quarkus/getting-started



Let's get started.

=== Creating the application

There are multiple ways to start a project. You can browse to https://code.quarkus.io and select some extensions, the build tool for your project and if you want some starter code. This will provide a project skeleton with the configured project dependencies and also contributes the information to compile the application natively.

But there is also an easy way using the Quarkus Maven plugin to load a project with this command:

.Operating system
. Linux and MacOs +
`mvn io.quarkus:quarkus-maven-plugin:2.0.2.Final:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=getting-started \
    -DclassName="org.acme.getting.started.GreetingResource" \
    -Dpath="/hello"`

. Windows +
    `mvn io.quarkus:quarkus-maven-plugin:2.0.2.Final:create "-DprojectGroupId=org.acme" "-DprojectArtifactId=getting-started" "-DclassName=org.acme.getting.started.GreetingResource" "-Dpath=/hello"`
 

it generates the following in the getting-started folder

* the Maven structure
* an org.acme.getting.started.GreetingResource resource exposed on /hello
* an associated unit test
* a landing page that is accessible on http://localhost:8080 after starting the application
* example Dockerfile files for both native and jvm modes in src/main/docker
* the application configuration file

Once generarted change your directory with `cd getting-started`and take a look at the *pom.xml*. You will find the import of the Quarkus BOM, allowing you to omit the version on the different Quarkus dependencies. In addition, you can see the *quarkus-maven-plugin* responsible for packaging of the application and also providing the development mode.

[source, xml]
----
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-universe-bom</artifactId>
            <version>${quarkus.platform.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>

<build>
    <plugins>
        <plugin>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-maven-plugin</artifactId>
            <version>${quarkus-plugin.version}</version>
            <extensions>true</extensions>
            <executions>
                <execution>
                    <goals>
                        <goal>build</goal>
                        <goal>generate-code</goal>
                        <goal>generate-code-tests</goal>
                    </goals>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
----

==== Extension management
Extensions added by creating a project from https://code.quarkus.io or with the parameter `-Dextensions` in your mvn create command and can be found after that in the pom.xml. Now we are just using *RESTEasy*. 

[source, xml]
----
    <dependency>
        <groupId>io.quarkus</groupId>
        <artifactId>quarkus-resteasy</artifactId>
    </dependency>
----

Later we will need an additional extension. Add an extension to an already created project by inserting the dependencies manually into the pom.xml or you can also use the mvn command `mvn quarkus:add-extension -Dextensions="container-image-docker"`.
This extension will be needed in <<Build native executables without GraalVM>> to build docker images with quarkus.


=== Running the application

The project was created with a simple `/hello` endpoint defined in *getting-started/src/java/org/acme/getting/started/GreetingResource.java* that will return "hello" to request on http://localhost:8080/hello.

[source, java]
----
@Path("/hello")
public class GreetingResource {

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return "Hello RESTEasy";
    }
}
----

Now run the application with the command `mvn quarkus:dev`. The application is running and you can send a request on the endpoint https://localhost:8080/hello and you should get a "Hello RESTEasy" response.

=== Developement mode 

With the command above we started the devon4quarkus app in development mode. Go to http://localhost:8080 and you can see a Quarkus landing page with information about the application. There you can access the http://localhost:8080/q/dev/[Dev UI] via the link. 

Quarkus apps expose a useful UI for inspecting and making on-the-fly changes to the app (much like live coding mode). It allows you to quickly visualize all the extensions currently loaded, see and edit their configuration values, see their status and go directly to their documentation.

More Information on this Chapter{Chapter Testing ?} or this Guide https://quarkus.io/guides/dev-ui

=== Testing the application 
When in developer mode (via mvn quarkus:dev), Quarkus can automatically and continuously rnun your uit tests. Quarkus supports Junit 5 tests and also has generated a simple test for us. When the devon4quarkus application is running you should see in your command promt:
----
Tests paused, press [r] to resume, [w] to open the browser, [h] for more options> 
----
The test is pretty simple and just checks if "Hello RESTEasy" will be returned. We can edit the *getting-started/src/java/org/acme/getting/started/GreetingResource.java* while the application is still running to:

[source, java]
----
@Path("/hello")
public class GreetingResource {

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return "Hello RESTHard";
    }
}
----

and by rerunning the test with `r`, the test should fail now. You can also test the application before running it with `mvn test`. Reset the return string to *"Hello RestEasy"* and we can continue.

=== Packaging the application
First let's package the application with `mvn package` and produce:


. *target/getting-started-1.0.0-SNAPSHOT.jar* +
containing just the classes and resources of the projects, it’s the regular artifact produced by the Maven build
. *target/quarkus-app/quarkus-run.jar* +
being an executable jar. Be aware that it’s not an über-jar as the dependencies are copied into several subdirectories (and would need to be included in any layered container image).

You can run the packaged application with this command `java -jar target/quarkus-app/quarkus-run.jar` and check http://localhost/hello.


Let’s now produce a native executable for our application. It improves the startup time of the application and produces a minimal disk footprint. The executable would have everything to run the application including the "JVM" (shrunk to be just enough to run the application), and the application.


Building a native executable requires using a distribution of GraalVM and a configured $GRAALVM_HOME. You can create a native application without GraalVM and use a multi-stage Docker build to run Maven inside a Docker container that embeds GraalVM. This will be explained in this chapter <<Build native executables without GraalVM>> or this https://quarkus.io/guides/building-native-image#container-runtime[guide]


The usage of GraalVM is easier on Linux, for Windows the setup for the environment takes some more steps.

.Operating system

. Linux
* First download the *Community Edition of GraalVM* from https://github.com/graalvm/graalvm-ce-builds/releases[here] and unpack it like you would any other archive. Make sure to download and install at Java 11 version. 
* Configure the environment variables with the command `export GRAALVM_HOME=<path_to_graalvm>/graalvm/` and install the native-image with the command `${GRAALVM_HOME}/bin/gu install native-image`. if you are having problems building the image also set *JAVA_HOME* to GraalVM directory with `export JAVA_HOME=${GRAALVM_HOME}`and add GraalVM to the *PATH* environment variable with `export PATH=${GRAALVM_HOME}/bin:$PATH`
* Build the native executable with the command `mvn package -Pnative` and a target folder with the native Linux binary *getting-started-1.0.0-SNAPSHOT-runner* will be created. Run the image with `target/getting-started-1.0.0-SNAPSHOT-runner` and you should see the fast startup time and if you inspect the process properties also the low memory usage. You can again access http://localhost/hello to check the application.

. Windows
* First download the *Community Edition of GraalVM* from https://github.com/graalvm/graalvm-ce-builds/releases[here] and unpack it like you would any other archive. Make sure to download and install at Java 11 version. 
* Configure the enviroment variables in the system properties or with the command `$Env:GRAALVM_HOME = "<path_to_graalvm>/graalvm"` and also set *JAVA_HOME* to GraalVM directory with `$Env:JAVA_HOME=${Env:GRAALVM_HOME}`and add GraalVM to the *PATH* enviroment variable with `§Env:PATH=${GRAALVM_HOME}/bin;$PATH`. Change your directory to *<path_to_graalvm>/graalvm/bin* and install the native-image with the command `gu install native-image`.
* Also an installation of the *Visual Studio 2017 Visual C++ Build Tools* is needed. You can load it from https://aka.ms/vs/15/release/vs_buildtools.exe[here].
* The creation of the native executable is only able in the x64 version of the *Native Tool Command Prompt for VS 2017*. Start the command prompt and jump into the *getting-started* folder. Build the native executable with the command `mvn package -Pnative` and a target folder with the executable *getting-started-1.0.0-SNAPSHOT-runner.exe* will be created. Start the application and you should see the fast startup time and if you inspect the process properties also the low memory usage. You can again access http://localhost/hello to check the application.


. MacOS
For MacOS just follow this guide https://quarkus.io/guides/building-native-image#prerequisites-for-oracle-graalvm-ceee.


==== Build native executables without GraalVM

You can build the Linux executables without installing GraalVM or sometimes you just need the Linux executables on Windows to run them in a container. To do that you need a working container runtime, we use Docker in this guide. You can install Docker with your DevonfwIde destribution just follow this description https://github.com/devonfw/ide/blob/master/documentation/docker.asciidoc#[Docker with DevonfwIde]. 

[sidebar]
.Docker on Windows
--
There are two modes for Docker on Windoes, if you are using it in Hyper-V mode and not WSL 2 mode you have to share the project drive in the Docker settings or you will face some problems. 
--
To create the djfnhjdbfjdfbjdfb just use this command
command `mvn package -Pnative "-Dquarkus.container-image.build=true"` normally quarkus automatically detects the container runtime, but some times a error occurs and than you should try to select it yourself with the parameter `"-Dquarkus.native.container-runtime=docker"´.

=== Creating container with the executables 

We can start building our container image for the project. The Maven command `mvn package -Pnative -Dquarkus.container-image.build=true` will build a container image for the project(You can omit the `-Pnative` parameter to create a Dockerfile with the .jar and not the native executable and with the `-Dquarkus.native.container-runtume=docker` you can explicitely select the container runtime).  



=== Whats next ?

The next guide will show you how to implement an ArC extension that provides CDI-based dependency injection and the integration of a database and deploy it to kubenetes.


This was a first glance over the functionality of devon4quarkus. If something is missing in this overview or you need more information, some in-depth going guides can be found at https://quarkus.io/guides/[Quarkus Guides] and the katacoda tutorials by https://www.katacoda.com/openshift/courses/developing-with-quarkus[OpenShift for Quarkus Developement].