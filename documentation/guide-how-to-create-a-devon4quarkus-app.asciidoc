:toc: macro
toc::[]

= How to create a devon4quarkus application

This guide should work as an introduction to the functionality given by https://quarkus.io/[Quarkus] and used in devon4quarkus and show to to build a first application.

== Quarkus 2.0 a Supersonic, Subatomic Java

 For years, the client-server architecture has been the de-facto standard to build applications. But a major shift happened. The one model rules them all age is over. A new range of applications and architecture styles has emerged and impacts how code is written and how applications are deployed and executed. HTTP microservices, reactive applications, message-driven microservices, and serverless are now central players in modern systems.

* Quarkus has been designed with this new world in mind and provides first-class support for these different paradigms. Quarkus development model morphs to adapt itself to the type of application you are developing.

* Quarkus is a Kubernetes Native Java stack tailored for GraalVM & OpenJDK HotSpot, crafted from the best-of-breed Java libraries and standards. Amazingly fast boot time, incredibly low RSS memory (not just heap size!) offering near-instant scale-up and high-density memory utilization in container orchestration platforms like Kubernetes. Quarkus uses a technique called compile-time boot. Learn more.

* Unifies Imperative and Reactive
Application requirements have changed drastically over the last few years. For any application to succeed in the era of cloud computing, big data, or IoT, going reactive is increasingly becoming the architecture style to follow.

* Quarkus combines both the familiar imperative code and the non-blocking reactive style when developing applications.

* Functions as a Service and Serverless
Thanks to their stellar startup time and low memory usage, you can implement functions using Quarkus to be used in serverless environments like AWS Lambda. You can use any of the Quarkus features in your function and benefit from the fast startup and low memory utilization. With Quarkus, you can embrace this new world without having to change your programming language.

* Developer Joy
Quarkus provides a cohesive platform for optimized developer joy:

* Unified configuration
Zero configs, live reload in the blink of an eye
Streamlined code for the 80% common usages, flexible for the 20%
No hassle native executable generation

The Guide will cover:

* How to build a simple "Hello World" Quarkus app serving a hello endpoint.
* A short introduction to Testing and the Development Mode
* Packaging the project and running as a self-contained jar file and producing a native executable. 

=== Prerequisites
To follow the guide and complete it, you need:
* an IDE or an editor to edit files
* JDK 11+ installed with KAVA_HOME configured appropriatly
* Apache Maven 3.8.1+


This Guide is heavily inspired by https://quarkus.io/guides/[Quarkus Guides] and the katacoda tutorials by https://www.katacoda.com/openshift/courses/developing-with-quarkus[OpenShift for Quarkus Developement]. I would recommend also using the Katacoda Tutorials to learn about devon4quarkus.


https://quarkus.io/guides/getting-started
https://www.katacoda.com/openshift/courses/developing-with-quarkus/getting-started



Let's get started.

=== Creating the application

There are multiple ways to start a project. You can browse to code.quarkus.io and select the extensions, build tool, and some Starter Code you want to use. This will provide a Project Skeleton with the configured project dependencies and also contribute the information to compile the application natively.

But there is also an easy way with this command:

.Operating system
. Linux and MacOs
    mvn io.quarkus:quarkus-maven-plugin:2.0.2.Final:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=getting-started \
    -DclassName="org.acme.getting.started.GreetingResource" \
    -Dpath="/hello"

. Windows
    mvn io.quarkus:quarkus-maven-plugin:2.0.2.Final:create "-DprojectGroupId=org.acme" "-DprojectArtifactId=getting-started" "-DclassName=org.acme.getting.started.GreetingResource" "-Dpath=/hello"
 

it generates the following in the getting-started folder

* the Maven structure
* an org.acme.getting.started.GreetingResource resource exposed on /hello
* an associated unit test
* a landing page that is accessible on http://localhost:8080 after starting the application
* example Dockerfile files for both native and jvm modes in src/main/docker
* the application configuration file

Once generated, look at the *pom.xml*. You will find the import of the Quarkus BOM, allowing you to omit the version on the different Quarkus dependencies. In addition, you can see the *quarkus-maven-plugin* responsible for packaging of the application and also providing the development mode.

[source, xml]
----
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-universe-bom</artifactId>
            <version>${quarkus.platform.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>

<build>
    <plugins>
        <plugin>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-maven-plugin</artifactId>
            <version>${quarkus-plugin.version}</version>
            <extensions>true</extensions>
            <executions>
                <execution>
                    <goals>
                        <goal>build</goal>
                        <goal>generate-code</goal>
                        <goal>generate-code-tests</goal>
                    </goals>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
----

==== Extension management
Extensions added by creating a project from code.quarkus.io or with the parameter `-Dextensions` in your mvn create command can be found in the pom.xml. Now we are just using *RESTEasy*.

[source, xml]
----
    <dependency>
        <groupId>io.quarkus</groupId>
        <artifactId>quarkus-resteasy</artifactId>
    </dependency>
----

Adding an extension to an already created Project and be done by inserting the dependencies manually into the pom.xml or you can also use the mvn command `mvn io.quarkus:quarkus-maven-plugin:2.0.2.Final:add-extensions -Dextensions=resteasy-reactive`

This was just a first impression of configuring methodes in devon4quarkus. There is a following guide that will show you some more methodes. 
//configuration Placeholder, ein Guide zur weiteren Configuration wird es auch geben?//

=== Running the application

The project was created with a simple `/hello` endpoint defined in *getting-started/src/java/org/acme/getting/started/GreetingResource.java* that will return "hello" to request on http://localhost:8080/hello.

[source, java]
----
@Path("/hello")
public class GreetingResource {

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return "Hello RESTEasy";
    }
}
----

Now we need to jump into the created *getting-started* folder to run the application with the command `mvn quarkus:dev`. The application is running and you can send a request on the endpoint https://localhost:8080/hello and you should get a "Hello RESTEasy" response.

=== Developement mode 

With the command above we started the devon4quarkus app in development mode. Go to http://localhost:8080 and you can see a Quarkus landing page with information about the application. There you can access the http://localhost:8080/q/dev/[Dev UI] via the link. 

Quarkus apps expose a useful UI for inspecting and making on-the-fly changes to the app (much like live coding mode). It allows you to quickly visualize all the extensions currently loaded, see and edit their configuration values, see their status and go directly to their documentation.

More Information on this Chapter or this Guide https://quarkus.io/guides/dev-ui
//DEV UI Placeholder einen weiteren Guide zu der Developer Mode sollte man auch machen.//

//=== Add Dependency Injection Chapter oder in einem weiteren Guide und direkt mit das projekt so umbauen und datenbankanbindung zeigen.

=== Test the application 
When in developer mode (via mvn quarkus:dev), Quarkus can automatically and continuously run your unit tests. Quarkus supports Junit 5 tests and also has generated a simple test for us. When the devon4quarkus application is running you should see in your command promt:
----
Tests paused, press [r] to resume, [w] to open the browser, [h] for more options> 
----
The test is pretty simple and just checks if "Hello RESTEasy" will be returned. We can edit the *getting-started/src/java/org/acme/getting/started/GreetingResource.java* while the application is still running to:

[source, java]
----
@Path("/hello")
public class GreetingResource {

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return "Hello RESTHard";
    }
}
----

and by rerunning the test with `r`, the test should fail now. You can also test the application before running it with `mvn test`. Reset the return String to *"Hello RestEasy"* and we can continue.

=== Packaging and run the application
First let's package the application with `mvn package` and produce
.

. *target/getting-started-1.0.0-SNAPSHOT.jar*
containing just the classes and resources of the projects, it’s the regular artifact produced by the Maven build
. *target/quarkus-app/quarkus-run.jar*
being an executable jar. Be aware that it’s not an über-jar as the dependencies are copied into several subdirectories (and would need to be included in any layered container image).

You can run the packaged application with this command `java -jar target/quarkus-app/quarkus-run.jar` and check http://localhost/hello.


Let’s now produce a native executable for our application. It improves the startup time of the application and produces a minimal disk footprint. The executable would have everything to run the application including the "JVM" (shrunk to be just enough to run the application), and the application.


Building a native executable requires using a distribution of GraalVM and a configured $GRAALVM_HOME. You can create a native application without GraalVM and use a multi-stage Docker build to run Maven inside a Docker container that embeds GraalVM. This will be explained in this https://quarkus.io/guides/building-native-image#container-runtime[Chapter]
// oder auch später im guide

The usage of GraalVM is easier on Linux, for Windows the setup for the environment takes more steps.

.Operating system

. Linux
* First download the Community Edition of GraalVM from https://github.com/graalvm/graalvm-ce-builds/releases[here] and unpack it like you would any other JDK. Make sure to download and install at Java 11 version. 
* Configure the environment variables with the command `export GRAALVM_HOME=<path_to_graalvm>/graalvm/` and install the native-image with the command `${GRAALVM_HOME}/bin/gu install native-image`. if you are having problems building the image also set *JAVA_HOME* to GraalVM directory with `export JAVA_HOME=${GRAALVM_HOME}`and add GraalVM to the *PATH* environment variable with `export PATH=${GRAALVM_HOME}/bin:$PATH`
* Now you can build the native executable with the command `mvn package -Pnative` and a target folder with the native Linux binary *getting-started-1.0.0-SNAPSHOT-runner* will be created. Run the image with `target/getting-started-1.0.0-SNAPSHOT-runner` and you should see the fast startup time and if you inspect the process properties also the low memory usage. You can again access http://localhost/hello to check the application.

. Windows
* First download the Community Edition of GraalVM from https://github.com/graalvm/graalvm-ce-builds/releases[here] and unpack it like you would any other JDK. Make sure to download and install at Java 11 version. 
* Configure the enviroment variables in the system properties or with the command `$Env:GRAALVM_HOME = "<path_to_graalvm>/graalvm"` and also set *JAVA_HOME* to GraalVM directory with `$Env:JAVA_HOME=${Env:GRAALVM_HOME}`and add GraalVM to the *PATH* enviroment variable with `§Env:PATH=${GRAALVM_HOME}/bin;$PATH`. Change your directory to *<path_to_graalvm>/graalvm/bin* and install the native-image with the command `gu install native-image`.
* Also an installation of the Visual Studio 2017 Visual C++ Build Tools is needed. You can load it from https://aka.ms/vs/15/release/vs_buildtools.exe[here].
* The creation of the native executable is only able in the x64 version of the Native Tool Command Prompt for VS 2017. Start the command prompt and jump into the *getting-started* folder. Build the native executable with the command `mvn package -Pnative` and a target folder with the executable *getting-started-1.0.0-SNAPSHOT-runner.exe* will be created. Start the application and you should see the fast startup time and if you inspect the process properties also the low memory usage. You can again access http://localhost/hello to check the application.


. MacOS
For MacOS just follow this guide https://quarkus.io/guides/building-native-image#prerequisites-for-oracle-graalvm-ceee.


==== Windows docker Way for Linux executables

// TODO//

==== Creating Container with the executables 


=== Whats next ?

The next Guide will show you how to implement an ArC extension that provides CDI-based dependency injection and the integration of a database.


This was a first glance over the functionality of devon4quarkus. If something is missing in this overview or you need more information, some in-depth going guides can be found at https://quarkus.io/guides/[Quarkus Guides] and the katacoda tutorials by https://www.katacoda.com/openshift/courses/developing-with-quarkus[OpenShift for Quarkus Developement].